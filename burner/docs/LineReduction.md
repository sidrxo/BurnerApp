# Line Count Reduction Opportunities

The `wc -l` snapshot shows several Swift files with 550+ lines; tackling the largest ones first will unlock the biggest wins.【443623†L3-L9】 Below are targeted ideas for trimming each file while keeping functionality intact.

## `Extensions/Services/StripePaymentService.swift` (~801 LOC)
* **Split responsibilities:** One class owns payment-intent prep, PaymentSheet orchestration, Apple Pay, manual card entry, saved card handling, and payment method CRUD. Each of those regions is 80–150 lines long and all live inside a single `ObservableObject`, making the file hard to navigate.【F:burner/Extensions/Services/StripePaymentService.swift†L13-L659】 Extract dedicated services (e.g., `PaymentIntentCoordinator`, `PaymentMethodRepository`, `ApplePayHandler`) so each file focuses on a single flow.
* **Deduplicate payment flow scaffolding:** `processPayment`, `processApplePayPayment`, `processCardPayment`, and `processSavedCardPayment` all repeat the same `isProcessing` toggles, call `createPaymentIntent`, configure Stripe clients, and handle identical success/error cases (including haptics).【F:burner/Extensions/Services/StripePaymentService.swift†L106-L412】【F:burner/Extensions/Services/StripePaymentService.swift†L542-L659】 A helper like `withPaymentIntent(eventId:perform:)` plus a shared `handleConfirmationResult` would collapse dozens of guard clauses and `MainActor.run` blocks.
* **Centralize payment method API wrappers:** `fetchPaymentMethods`, `savePaymentMethod`, `deletePaymentMethod`, and `setDefaultPaymentMethod` are thin wrappers with identical Firestore guard/response parsing logic.【F:burner/Extensions/Services/StripePaymentService.swift†L462-L601】 Converting the boilerplate into a reusable `callStripeFunction(name:payload:)` (or even moving it to a repository struct) would cut repeated serialization code.
* **Move auth/Apple helper types out of the file:** The embedded `AuthenticationContext` at the bottom is unrelated to payment intent logic.【F:burner/Extensions/Services/StripePaymentService.swift†L662-L801】 Relocating helper classes to their own files keeps this service focused and shortens it by ~70 lines.

## `Settings/ScannerView.swift` (~702 LOC)
* **Factor alert overlays into reusable views:** The top of the file repeats three `CustomAlertView` configurations plus the manual-entry sheet, each with duplicated typography and button styling.【F:burner/Settings/ScannerView.swift†L46-L170】 Extract a `ScannerAlertOverlay` component and a `ManualEntrySheet` view to drop ~80 lines from the main body.
* **Separate permission/event loading logic:** Methods such as `checkScannerAccessFromClaims`, `fetchUserRoleFromClaims`, `fetchTodaysEvents`, and `loadPersistedEventSelection` live alongside UI definitions and mix async work with debug `print` spam.【F:burner/Settings/ScannerView.swift†L193-L444】 Moving those into a `ScannerViewModel` (or at least a dedicated extension) keeps the SwiftUI view lean.
* **Consolidate scan validation + network handling:** `validateAndScanTicket` spans ~150 lines of guards, logging, and error mapping before/after calling the Cloud Function.【F:burner/Settings/ScannerView.swift†L460-L638】 Break it into helpers for “determineTicketId”, “callScanFunction”, and “displayScanResult” so each piece is testable and reusable (manual entry taps could reuse the same ticket-ID extraction logic without branching inside the core method).

## `Tickets/TicketPurchaseView.swift` (~603 LOC)
* **Reuse button + step layouts:** The `.paymentMethod`, `.cardInput`, and `.savedCards` branches all compose the same `priceSummary`, dividers, and button chrome with slight variations.【F:burner/Tickets/TicketPurchaseView.swift†L36-L200】 Turning the Apple Pay / card CTAs into dedicated view structs (e.g., `PurchaseCTA(style:action:)`) and parameterized pay buttons will eliminate near-duplicate modifiers.
* **Normalize payment handlers:** `handleApplePayPayment`, `handleCardPayment`, and `handleSavedCardPayment` share the same “prevent duplicate purchase”, “ensure auth + event id”, “call service”, and “reset flags” logic, only varying in the payment method used.【F:burner/Tickets/TicketPurchaseView.swift†L471-L602】 A single `performPurchase(flow: PurchaseFlow)` routine could accept an enum describing the payment flavor and cut 50+ lines of guard statements.
* **Delegate payment service state:** `TicketPurchaseView` owns `StripePaymentService`, manages alerts, and updates event data. Pushing payment orchestration into a view model (alongside `hasInitiatedPurchase` / `alertMessage` state) keeps the SwiftUI body declarative and reduces the number of `@State` variables at the top of the file.【F:burner/Tickets/TicketPurchaseView.swift†L9-L33】

## `ExploreView.swift` (~683 LOC)
* **Programmatic section builder:** `buildContentSections` manually enumerates eight blocks (featured, popular, this week, etc.) and repeats the same `EventSection` initializer with different data sets.【F:burner/ExploreView.swift†L264-L399】 Store the sections in a `struct ExploreSection { let title: String; let events: [Event]; ... }` array and loop to remove most of the copy/paste.
* **Consolidate filtering helpers:** Properties such as `thisWeekEvents`, `popularEvents`, `nearbyEvents`, and `allEventsForGenre` all perform similar filtering/sorting of `eventViewModel.events`. Shared predicates (e.g., “is upcoming & not featured”) or an `EventFilter` utility would reduce repeated Calendar math and guard clauses.【F:burner/ExploreView.swift†L18-L142】
* **Break the view into subviews:** `contentView`, `nearbySection`, genre lists, and hero cards all sit in one file, inflating it even further. Extracting `NearbyEventsCard`, `GenreSectionList`, etc., would distribute responsibility and encourage reuse across other tabs.【F:burner/ExploreView.swift†L273-L420】

## `Settings/SignInSheetView.swift` (~610 LOC)
* **Isolate authentication flows from presentation:** The view renders backgrounds, buttons, and overlays while also owning every auth handler (Google, Apple, passwordless), profile creation, nonce helpers, and even `ASAuthorizationController` delegates.【F:burner/Settings/SignInSheetView.swift†L9-L360】【F:burner/Settings/SignInSheetView.swift†L365-L607】 Moving auth logic to a `SignInCoordinator` or view model allows the SwiftUI sheet to declare UI + state bindings only.
* **Share button styling:** The three “SIGN IN WITH …” buttons all duplicate the same `HStack`, icon/text spacing, and `.primaryButtonStyle` modifiers.【F:burner/Settings/SignInSheetView.swift†L188-L219】 Wrap them in a `SignInButton` component that accepts the label/icon/colors to cut ~40 lines and keep branding consistent.
* **Modularize Apple helper types:** `AppleSignInDelegate` and `ApplePresentationContextProvider` add another 60 lines at the bottom of the view file.【F:burner/Settings/SignInSheetView.swift†L540-L601】 Extracting them (or using Combine publishers) keeps platform-specific glue separate from SwiftUI code.

## `Tickets/TicketDetailView.swift` (~600 LOC)
* **Extract the ticket layout:** `modernTicketView` is over 150 lines of nested layout for status badges, date/time blocks, QR code, and locked state messaging.【F:burner/Tickets/TicketDetailView.swift†L124-L320】 Breaking this into smaller components (`TicketHeader`, `TicketAccessSection`, etc.) lets other screens reuse the same pieces and simplifies conditional rendering.
* **Reuse QR code presentation:** `FullScreenQRCodeView` reimplements the event title, venue, QR code, and close button layout that already exists in the main ticket view.【F:burner/Tickets/TicketDetailView.swift†L432-L520】 Build a single `TicketQRCode` view that both contexts host, eliminating redundant typography and modifier chains.
* **Move Live Activity utilities into a manager:** Lifecycle hooks (`autoStartLiveActivityForEventDay`, `checkLiveActivityStatus`, `updateLiveActivityIfNeeded`) reside inside the view even though they don’t reference UI state beyond two booleans.【F:burner/Tickets/TicketDetailView.swift†L146-L441】 A dedicated `TicketLiveActivityController` (with callbacks) would reduce file size and improve testability.
